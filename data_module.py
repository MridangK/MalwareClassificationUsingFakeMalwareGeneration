""" Create Data Module

Usage

>>> python -m src.data.data_module

"""

import glob
import logging
import os

import coloredlogs
import hydra
import numpy as np
import omegaconf
from omegaconf import DictConfig

from src.utils.utils import PROJECT_ROOT, MyTimer, MALWARE_LABELS

logger = logging.getLogger(__name__)
coloredlogs.install(level=logging.DEBUG, logger=logger)


class MyDataModule:
    """Build data module"""

    def __init__(self, datasets: DictConfig) -> None:
        """ Initialize data variables from hydra config

        Args:
            datasets (DictConfig): dataset contains train
        """
        self.datasets = datasets

    def prepare_data(self) -> tuple:
        data_path = []
        paths = (
            self.datasets.train.processed_malware_path,
            self.datasets.train.fake_malware_path
        )

        # Check if all paths to dataset exist
        for path in paths:
            new_path = os.path.join(PROJECT_ROOT, path)

            if not os.path.exists(new_path):
                raise FileNotFoundError(
                    f"Path {new_path} was not found. "
                    f"Current dir: {os.getcwd()}"
                )

            data_path.append(new_path)

        sample_size, X_real, y_real = self.load_real_malware(
            path=data_path[0], ratio=self.datasets.train.real_malware_ratio
        )

        X_fake, y_fake = self.load_fake_malware(
            path=data_path[1], sample_size=sample_size,
            ratio=self.datasets.train.fake_malware_ratio
        )

        logger.info(
            f'Finished Loading Dataset --- Total Sample Size: {sample_size}'
        )

        return sample_size, X_real, y_real, X_fake, y_fake

    def load_real_malware(self, path: str, ratio: int) -> tuple:
        X_real = []
        y_real = []
        sample_size = dict()

        logger.info('Loading real malware dataset ...')

        for malware_family in os.listdir(path):
            malware_path = os.path.join(path, malware_family, '*.npy')
            files = glob.glob(malware_path)
            sample_size[malware_family] = len(files)

            embeddings = []
            for file in files:
                content = np.load(file)

                # Scale real malware embeddings to range of [-1, 1]
                # scaled_embedding = self.scale_data(embedded_data=content)

                embeddings.append(content)

            embeddings = self.scale_data(embedded_data=embeddings)
            X_real.extend(embeddings)

            labels = np.array(
                [MALWARE_LABELS[malware_family]] * sample_size[malware_family]
            )
            y_real.extend(labels)

        # Squeeze dimension 14708 x 1 x 768 into 14708 x 768
        X_real = np.squeeze(X_real)


        return sample_size, X_real, y_real

    def load_fake_malware(self, path: str, sample_size: dict,
                          ratio: int) -> tuple:
        X_fake = []
        y_fake = []

        logger.info('Loading fake malware dataset ...')

        for malware_family in os.listdir(path):
            malware_path = os.path.join(path, malware_family, '*.npy')
            files = glob.glob(malware_path)

            max_file_count = sample_size[malware_family] * ratio

            data = []
            for file in files:
                content = np.load(file)
                data.append(content)
                if len(data) >= max_file_count:
                    X_fake.extend(data)
                    break
            labels = np.array(
                [MALWARE_LABELS[malware_family]] * len(data)
            )
            y_fake.extend(labels)

        if ratio == 0:
            X_fake, y_fake = [], []
        else:
            X_fake = np.squeeze(X_fake)

        return X_fake, y_fake

    def scale_data(self, embedded_data: list) -> list:
        embedded_data = self.integer_mapping(embedded_data)

        # Scale to [-1, 1]
        min_val = np.amin(embedded_data)
        max_val = np.amax(embedded_data)
        embedded_data = 2 * (embedded_data - min_val) / (max_val - min_val) - 1

        return embedded_data

    def integer_mapping(self, data: list):
        sub_ranges = np.linspace(-1, 1, num=30)
        sub_range_indices = np.digitize(data, sub_ranges)

        return sub_range_indices


@hydra.main(config_path=str(PROJECT_ROOT / "conf"),
            config_name="default", version_base=None)
def main(cfg: omegaconf.DictConfig):
    logger.propagate = False

    # Start timer
    my_timer = MyTimer()

    datamodule = hydra.utils.instantiate(cfg.data.datamodule,
                                         _recursive_=False)

    sample_size, X_real, y_real, X_fake, y_fake = datamodule.prepare_data()
    print(f'Real sample size: {len(X_real)}')
    print(f'Fake sample size: {len(X_fake)}')
    print(f"Execution Time: {my_timer.get_execution_time()}")


if __name__ == '__main__':
    main()
