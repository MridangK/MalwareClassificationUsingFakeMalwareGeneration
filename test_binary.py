import logging
import os

import coloredlogs
import hydra
import numpy as np
import omegaconf
import tensorflow as tf
from sklearn.svm import SVC
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.model_selection import GridSearchCV
import mlflow
from sklearn.model_selection import train_test_split
from omegaconf import DictConfig
from sklearn.svm import OneClassSVM

from src.utils.utils import PROJECT_ROOT, MALWARE_LABELS, MyTimer, log_params

os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'

logger = logging.getLogger(__name__)
coloredlogs.install(level=logging.DEBUG, logger=logger)

logging.getLogger('git').setLevel(logging.ERROR)
logging.getLogger('urllib3').setLevel(logging.ERROR)
logging.getLogger('matplotlib').setLevel(logging.ERROR)
logging.getLogger('tensorflow').setLevel(logging.ERROR)
logging.getLogger('h5py').setLevel(logging.ERROR)

def train_and_eval(cfg: DictConfig):
    datamodule = hydra.utils.instantiate(
        cfg.data.datamodule, _recursive_=False
    )

    sample_size, X_real, y_real, X_fake, y_fake = datamodule.prepare_data()
    y_real = np.array(y_real)
    y_fake = np.array(y_fake)
    real_wws, real_zbot = [], []
    for i in range(len(y_real)):
        if y_real[i] == 0:
            real_wws.append(X_real[i])
        elif y_real[i] == 1:
            real_zbot.append(X_real[i])

    fake_wws, fake_zbot = [], []
    for i in range(len(y_fake)):
        if y_fake[i] == 0:
            fake_wws.append(X_fake[i])
        elif y_fake[i] == 1:
            fake_zbot.append(X_fake[i])

    # Train on fake, test on real
    y_train_wws = np.zeros(len(real_wws))
    y_train_zbot = np.full(len(real_zbot), 1)

    X_train = np.concatenate((real_wws, real_zbot))
    y_train = np.concatenate((y_train_wws, y_train_zbot))

    y_test_wws = np.zeros(len(fake_wws))
    y_test_zbot = np.full(len(fake_zbot), 1)

    X_test = np.concatenate((fake_wws, fake_zbot))
    y_test = np.concatenate((y_test_wws, y_test_zbot))


    '''# Train on fake+real, test on fake+real (classify fake vs real)
    y_real = np.zeros(len(X_real))
    y_fake = np.full(len(X_fake), 1)

    X = np.concatenate((X_real, X_fake))
    y = np.concatenate((y_real, y_fake))

    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=cfg.train_eval.random_state
    )
    '''

    clf = SVC(
        C=3, kernel='rbf', degree=3, gamma='scale', random_state=777
    )

    train_acc = clf.fit(X_train, y_train).score(X_train, y_train)
    print(f'Train_Acc: {train_acc}')

    test_acc = clf.score(X_test, y_test)
    print(f'Test_Acc: {test_acc}')

    pred = clf.predict(X_test)
    cm = confusion_matrix(y_test, pred, labels=clf.classes_)
    disp = ConfusionMatrixDisplay(cm, display_labels=['winwebsec', 'zbot'])
    disp.plot()
    plt.title('Binary Clf - train real, test fake --- C=3')
    plt.xticks(rotation=-45)
    plt.show()


@hydra.main(config_path=str(PROJECT_ROOT / 'conf'),
            config_name='default', version_base=None)
def main(cfg: omegaconf.DictConfig):
    train_and_eval(cfg)


if __name__ == '__main__':
    logger.propagate = False
    logger.info("Num GPUs Available: "
                f"{len(tf.config.list_physical_devices('GPU'))}")
    main()